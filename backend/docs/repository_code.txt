

================================================================================
FILE: Dockerfile
================================================================================

# Build stage for frontend
FROM node:18-alpine as frontend-build

WORKDIR /app/frontend

# Copy frontend package files
COPY frontend/package*.json ./
RUN npm install

# Copy frontend source
COPY frontend/ ./
COPY shared/ ../shared/

# Create production .env
RUN echo "VITE_API_URL=https://app2.hezh-digital.ru/api" > .env.production && \
    echo "VITE_SSE_URL=https://app2.hezh-digital.ru/api/events" >> .env.production && \
    echo "VITE_WEBAPP_URL=https://app2.hezh-digital.ru" >> .env.production

# Build frontend
RUN npm run build

# Build stage for backend
FROM python:3.11-slim as backend-build

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy backend requirements
COPY backend/requirements.txt ./requirements.txt

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Production stage
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies including curl for healthcheck
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy Python dependencies from build stage
COPY --from=backend-build /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=backend-build /usr/local/bin /usr/local/bin

# Copy backend code
COPY backend/ ./backend/

# Copy built frontend
COPY --from=frontend-build /app/frontend/dist ./frontend/dist/

# Copy shared files
COPY shared/ ./shared/

# Create data directory
RUN mkdir -p /app/data

# Expose port
EXPOSE 8000

# Start the FastAPI application
CMD ["uvicorn", "backend.app.main:app", "--host", "0.0.0.0", "--port", "8000"]

================================================================================
FILE: parse.py
================================================================================

import os
import pathlib

def export_repo_to_text(root_dir, output_file, include_extensions=None, exclude_dirs=None):
    """–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç –∫–æ–¥ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è –≤ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª"""
    if include_extensions is None:
        include_extensions = ['.py', '.js', '.html', '.css', '.md', '.java', '.c', '.cpp', '.h']
    
    if exclude_dirs is None:
        exclude_dirs = ['.git', '__pycache__', 'node_modules', 'venv', '.venv', 'env', 'dist', 'build']
    
    # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫–∏ –¥–ª—è –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    root_dir = pathlib.Path(root_dir).resolve()
    exclude_dirs_set = set(exclude_dirs)

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            root_path = pathlib.Path(root)
            
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π (–ø–æ –∏–º–µ–Ω–∏)
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set]
            
            for file in files:
                file_path = root_path / file
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
                if file_path.suffix not in include_extensions:
                    continue

                # –ü—Ä–æ–ø—É—Å–∫ –µ—Å–ª–∏ –ø—É—Ç—å —Å–æ–¥–µ—Ä–∂–∏—Ç –∏—Å–∫–ª—é—á—ë–Ω–Ω—É—é –ø–∞–ø–∫—É (–Ω–∞–ø—Ä–∏–º–µ—Ä: .../.venv/...)
                if any(part in exclude_dirs_set for part in file_path.parts):
                    continue
                
                try:
                    # –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ñ–∞–π–ª–∞
                    rel_path = file_path.relative_to(root_dir)
                    outfile.write(f"\n\n{'=' * 80}\n")
                    outfile.write(f"FILE: {rel_path}\n")
                    outfile.write(f"{'=' * 80}\n\n")
                    
                    # –ß—Ç–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                        
                except UnicodeDecodeError:
                    outfile.write(f"\n\n[BINARY FILE: {rel_path} - SKIPPED]\n")
                except Exception as e:
                    outfile.write(f"\n\n[ERROR READING {rel_path}: {str(e)}]\n")

if __name__ == "__main__":
    REPO_DIR = pathlib.Path(__file__).parent.resolve()
    OUTPUT_PATH = REPO_DIR / "docs/repository_code.txt"
    
    print(f"–°—Ç–∞—Ä—Ç —ç–∫—Å–ø–æ—Ä—Ç–∞ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è: {REPO_DIR}")
    print(f"–í—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª: {OUTPUT_PATH}")
    
    export_repo_to_text(
        root_dir=REPO_DIR,
        output_file=str(OUTPUT_PATH),
        include_extensions=[".py", ".js", ".html", ".css", ".md", ".ts", ".json",".tsx", "yml", ""],
        exclude_dirs=[".git", "__pycache__", "venv", ".venv", "env", "dist", "build", "node_modules"]
    )
    
    print(f"–≠–∫—Å–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à–µ–Ω! –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: {os.path.getsize(OUTPUT_PATH)/1024:.2f} KB")


================================================================================
FILE: alembic\env.py
================================================================================



================================================================================
FILE: alembic\__init__.py
================================================================================



================================================================================
FILE: alembic\versions\__init__.py
================================================================================



================================================================================
FILE: app\data_init.py
================================================================================

import logging
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from .core.database import AsyncSessionLocal
from .models.models import Country, Service, User, Setting, Statistic
from .schemas.schemas import CountryStatus
from datetime import datetime
import uuid

logger = logging.getLogger(__name__)

async def initialize_data():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –ë–î –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
    async with AsyncSessionLocal() as db:
        try:
            await _init_countries(db)
            await _init_services(db)
            await _init_sample_user(db)
            await _init_settings(db)
            await _init_statistics(db)
            
            await db.commit()
            logger.info("Initial data initialization completed")
            
        except Exception as e:
            logger.error(f"Error initializing data: {e}")
            await db.rollback()
            raise

async def _init_countries(db: AsyncSession):
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–∞–Ω—ã –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞–ø–∏—Å–∏
    result = await db.execute(select(Country))
    if result.scalars().first():
        logger.info("Countries already exist, skipping initialization")
        return
    
    countries_data = [
        {
            "name": "–†–æ—Å—Å–∏—è",
            "code": "RU", 
            "flag": "üá∑üá∫",
            "price_from": 15,
            "available": True,
            "numbers_count": 1234,
            "status": CountryStatus.AVAILABLE.value
        },
        {
            "name": "–£–∫—Ä–∞–∏–Ω–∞",
            "code": "UA",
            "flag": "üá∫üá¶", 
            "price_from": 22,
            "available": True,
            "numbers_count": 856,
            "status": CountryStatus.AVAILABLE.value
        },
        {
            "name": "–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω",
            "code": "KZ",
            "flag": "üá∞üáø",
            "price_from": 18,
            "available": True,
            "numbers_count": 12,
            "status": CountryStatus.LOW.value
        },
        {
            "name": "–°–®–ê",
            "code": "US",
            "flag": "üá∫üá∏",
            "price_from": 45,
            "available": False,
            "numbers_count": 0,
            "status": CountryStatus.UNAVAILABLE.value
        }
    ]
    
    for country_data in countries_data:
        country = Country(
            id=str(uuid.uuid4()),
            **country_data
        )
        db.add(country)
    
    logger.info(f"Created {len(countries_data)} countries")

async def _init_services(db: AsyncSession):
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–µ—Ä–≤–∏—Å—ã –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
    result = await db.execute(select(Service))
    if result.scalars().first():
        logger.info("Services already exist, skipping initialization")
        return
    
    services_data = [
        {
            "name": "Telegram",
            "icon": "fab fa-telegram",
            "price_from": 15,
            "price_to": 25,
            "available": True
        },
        {
            "name": "WhatsApp", 
            "icon": "fab fa-whatsapp",
            "price_from": 18,
            "price_to": 30,
            "available": True
        },
        {
            "name": "Discord",
            "icon": "fab fa-discord",
            "price_from": 20,
            "price_to": 35,
            "available": True
        }
    ]
    
    for service_data in services_data:
        service = Service(
            id=str(uuid.uuid4()),
            **service_data
        )
        db.add(service)
    
    logger.info(f"Created {len(services_data)} services")

async def _init_sample_user(db: AsyncSession):
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
    sample_telegram_id = "sample_user"
    
    result = await db.execute(
        select(User).where(User.telegram_id == sample_telegram_id)
    )
    existing_user = result.scalars().first()
    
    if existing_user:
        logger.info("Sample user already exists, skipping initialization")
        return
    
    user = User(
        id=str(uuid.uuid4()),
        telegram_id=sample_telegram_id,
        username="testuser",
        first_name="Test",
        last_name="User",
        balance=12550,  # 125.50 —Ä—É–±–ª–µ–π –≤ –∫–æ–ø–µ–π–∫–∞—Ö
        is_admin=True
    )
    
    db.add(user)
    logger.info("Created sample user")

async def _init_settings(db: AsyncSession):
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
    result = await db.execute(select(Setting))
    if result.scalars().first():
        logger.info("Settings already exist, skipping initialization")
        return
    
    settings_data = [
        {
            "key": "commission_percent",
            "value": "5",
            "description": "–ö–æ–º–∏—Å—Å–∏—è –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö"
        },
        {
            "key": "min_balance",
            "value": "100", 
            "description": "–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å –≤ –∫–æ–ø–µ–π–∫–∞—Ö"
        },
        {
            "key": "support_url",
            "value": "https://t.me/support",
            "description": "–°—Å—ã–ª–∫–∞ –Ω–∞ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É"
        },
        {
            "key": "telegram_channel",
            "value": "https://t.me/onlinesim_channel",
            "description": "–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª Telegram"
        }
    ]
    
    for setting_data in settings_data:
        setting = Setting(
            id=str(uuid.uuid4()),
            updated_at=datetime.now(),
            **setting_data
        )
        db.add(setting)
    
    logger.info(f"Created {len(settings_data)} settings")

async def _init_statistics(db: AsyncSession):
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
    result = await db.execute(select(Statistic))
    if result.scalars().first():
        logger.info("Statistics already exist, skipping initialization")
        return
    
    today = datetime.now().strftime("%Y-%m-%d")
    yesterday = datetime.now().replace(day=datetime.now().day - 1).strftime("%Y-%m-%d")
    
    statistics_data = [
        {
            "date": today,
            "total_orders": 45,
            "total_revenue": 125000,
            "new_users": 12, 
            "active_users": 89
        },
        {
            "date": yesterday,
            "total_orders": 38,
            "total_revenue": 98500,
            "new_users": 8,
            "active_users": 76
        }
    ]
    
    for stat_data in statistics_data:
        statistic = Statistic(
            id=str(uuid.uuid4()),
            **stat_data
        )
        db.add(statistic)
    
    logger.info(f"Created {len(statistics_data)} statistics records")

================================================================================
FILE: app\main.py
================================================================================

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
import os
import logging
from contextlib import asynccontextmanager

from .core.config import settings
from .core.database import create_tables
from .init_data import initialize_data
from .api.routes import router
from .services.sms.adapter import SMSAdapter

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è SMS –∞–¥–∞–ø—Ç–µ—Ä–∞
sms_adapter = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    global sms_adapter
    
    # Startup
    try:
        # 1. –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –ë–î –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
        logger.info("Creating database tables...")
        await create_tables()
        logger.info("‚úÖ Database tables created")
        
        # 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
        logger.info("Loading initial data...")
        await initialize_data()
        logger.info("‚úÖ Initial data loaded")
        
        # 3. SMS –∞–¥–∞–ø—Ç–µ—Ä
        logger.info("Initializing SMS adapter...")
        sms_adapter = SMSAdapter(
            provider_name=getattr(settings, 'sms_provider', 'dummy'),
            api_key=getattr(settings, 'sms_api_key', None)
        )
        logger.info("‚úÖ SMS adapter initialized")
        
    except Exception as e:
        logger.error(f"‚ùå Initialization failed: {e}")
        # Fallback
        if sms_adapter is None:
            sms_adapter = SMSAdapter(provider_name="dummy")
    
    yield
    
    # Shutdown
    logger.info("Shutting down...")

# –°–æ–∑–¥–∞–Ω–∏–µ FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
app = FastAPI(
    title="OnlineSim API",
    description="API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è SMS –Ω–∞ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ –Ω–æ–º–µ—Ä–∞",
    version="1.0.0",
    lifespan=lifespan
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –º–∞—Ä—à—Ä—É—Ç–æ–≤ API
app.include_router(router, prefix="/api")

# –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã (—Ñ—Ä–æ–Ω—Ç–µ–Ω–¥)
if os.path.exists("/app/frontend/dist"):
    app.mount("/static", StaticFiles(directory="/app/frontend/dist"), name="static")
    
    @app.get("/")
    async def read_root():
        """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º index.html —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞"""
        return FileResponse("/app/frontend/dist/index.html")
    
    @app.get("/{full_path:path}")
    async def catch_all(full_path: str):
        """–ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ index.html –¥–ª—è SPA"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—Ä–æ—Å –ª–∏ —ç—Ç–æ –∫ API
        if full_path.startswith("api/"):
            return {"error": "Not found"}
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ñ–∞–π–ª
        file_path = f"/app/frontend/dist/{full_path}"
        if os.path.exists(file_path) and os.path.isfile(file_path):
            return FileResponse(file_path)
        
        # –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º index.html
        return FileResponse("/app/frontend/dist/index.html")

@app.get("/health")
async def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞"""
    return {
        "status": "ok",
        "sms_provider": settings.sms_provider if sms_adapter else "not initialized"
    }

def get_sms_adapter() -> SMSAdapter:
    """–ü–æ–ª—É—á–∏—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä SMS –∞–¥–∞–ø—Ç–µ—Ä–∞"""
    global sms_adapter
    if sms_adapter is None:
        # –°–æ–∑–¥–∞–µ–º fallback –∞–¥–∞–ø—Ç–µ—Ä –µ—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
        sms_adapter = SMSAdapter(provider_name="dummy")
    return sms_adapter

================================================================================
FILE: app\__init__.py
================================================================================



================================================================================
FILE: app\api\routes.py
================================================================================

from fastapi import APIRouter, HTTPException, Depends, Request
from typing import List, Dict, Any
import logging
import json

logger = logging.getLogger(__name__)
router = APIRouter()

# –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
MOCK_COUNTRIES = [
    {
        "id": "0",
        "name": "–†–æ—Å—Å–∏—è", 
        "code": "RU",
        "flag": "üá∑üá∫",
        "priceFrom": 15,
        "available": True,
        "numbersCount": 1234,
        "status": "available"
    },
    {
        "id": "1", 
        "name": "–£–∫—Ä–∞–∏–Ω–∞",
        "code": "UA", 
        "flag": "üá∫üá¶",
        "priceFrom": 22,
        "available": True,
        "numbersCount": 856,
        "status": "available"
    },
    {
        "id": "2",
        "name": "–ë–µ–ª–∞—Ä—É—Å—å",
        "code": "BY",
        "flag": "üáßüáæ", 
        "priceFrom": 18,
        "available": True,
        "numbersCount": 645,
        "status": "available"
    },
    {
        "id": "3",
        "name": "–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω", 
        "code": "KZ",
        "flag": "üá∞üáø",
        "priceFrom": 20,
        "available": True, 
        "numbersCount": 432,
        "status": "available"
    }
]

MOCK_SERVICES = [
    {
        "id": "tg",
        "name": "Telegram",
        "icon": "fab fa-telegram-plane",
        "priceFrom": 15,
        "priceTo": 25, 
        "available": True
    },
    {
        "id": "wa",
        "name": "WhatsApp", 
        "icon": "fab fa-whatsapp",
        "priceFrom": 18,
        "priceTo": 30,
        "available": True
    },
    {
        "id": "vk", 
        "name": "VKontakte",
        "icon": "fab fa-vk",
        "priceFrom": 12,
        "priceTo": 20,
        "available": True
    },
    {
        "id": "ok",
        "name": "Odnoklassniki",
        "icon": "fas fa-circle", 
        "priceFrom": 10,
        "priceTo": 15,
        "available": True
    }
]

@router.get("/countries")
async def get_countries() -> List[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—Ç—Ä–∞–Ω"""
    try:
        logger.info("Getting countries list")
        result = MOCK_COUNTRIES
        logger.info(f"Returning {len(result)} countries: {[c['name'] for c in result]}")
        return result
    except Exception as e:
        logger.error(f"Error getting countries: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/services") 
async def get_services() -> List[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤"""
    try:
        logger.info("Getting services list")
        result = MOCK_SERVICES
        logger.info(f"Returning {len(result)} services: {[s['name'] for s in result]}")
        return result
    except Exception as e:
        logger.error(f"Error getting services: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/users/{user_id}")
async def get_user(user_id: str) -> Dict[str, Any]:
    """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ"""
    try:
        logger.info(f"Getting user info for: {user_id}")
        # –ú–æ–∫ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        return {
            "id": user_id,
            "username": user_id,
            "balance": 100.50,
            "orders": [],
            "created_at": "2024-01-01T00:00:00Z"
        }
    except Exception as e:
        logger.error(f"Error getting user {user_id}: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/orders")
async def get_orders(user_id: str = None) -> List[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        logger.info(f"Getting orders for user: {user_id}")
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –¥–ª—è –Ω–∞—á–∞–ª–∞
        result = []
        logger.info(f"Returning {len(result)} orders")
        return result
    except Exception as e:
        logger.error(f"Error getting orders: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# –î–æ–±–∞–≤–ª—è–µ–º endpoint –¥–ª—è —Å–µ—Ä–≤–∏—Å–æ–≤ –ø–æ —Å—Ç—Ä–∞–Ω–µ (–º–æ–∂–µ—Ç –±—ã—Ç—å –Ω—É–∂–µ–Ω —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥—É)
@router.get("/countries/{country_id}/services")
async def get_services_by_country(country_id: str) -> List[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π —Å—Ç—Ä–∞–Ω—ã"""
    try:
        logger.info(f"Getting services for country: {country_id}")
        result = MOCK_SERVICES  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ –∂–µ —Å–µ—Ä–≤–∏—Å—ã
        logger.info(f"Returning {len(result)} services for country {country_id}")
        return result
    except Exception as e:
        logger.error(f"Error getting services for country {country_id}: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# –î–æ–±–∞–≤–ª—è–µ–º endpoint –¥–ª—è —Ü–µ–Ω (–º–æ–∂–µ—Ç –±—ã—Ç—å –Ω—É–∂–µ–Ω)
@router.get("/prices")
async def get_prices() -> List[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ü–µ–Ω –¥–ª—è —Å—Ç—Ä–∞–Ω/—Å–µ—Ä–≤–∏—Å–æ–≤"""
    try:
        logger.info("Getting prices list")
        result = [
            {"country_id": "0", "service_id": "tg", "price": 15},
            {"country_id": "0", "service_id": "wa", "price": 18},
            {"country_id": "1", "service_id": "tg", "price": 22},
            {"country_id": "1", "service_id": "wa", "price": 25}
        ]
        logger.info(f"Returning {len(result)} prices")
        return result
    except Exception as e:
        logger.error(f"Error getting prices: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# –î–æ–±–∞–≤–ª—è–µ–º catch-all –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö endpoints
@router.get("/{path:path}")
async def catch_all(path: str):
    """–ü–µ—Ä–µ—Ö–≤–∞—Ç—á–∏–∫ –¥–ª—è –≤—Å–µ—Ö –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö API –ø—É—Ç–µ–π"""
    logger.warning(f"Unknown API endpoint requested: /{path}")
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    return []

@router.post("/orders")
async def create_order(request: Request) -> Dict[str, Any]:
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑ –Ω–æ–º–µ—Ä–∞"""
    try:
        # –ß–∏—Ç–∞–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        body = await request.body()
        logger.info(f"Raw request body: {body}")
        
        # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–æ–±—Ä–∞—Ç—å JSON
        try:
            order_data = json.loads(body) if body else {}
        except json.JSONDecodeError as e:
            logger.error(f"JSON decode error: {e}")
            order_data = {}
        
        logger.info(f"Parsed order data: {order_data}")
        
        # –ë–æ–ª–µ–µ –º—è–≥–∫–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è - –±–µ—Ä–µ–º —á—Ç–æ –µ—Å—Ç—å
        user_id = order_data.get("user_id", order_data.get("userId", "sample_user"))
        country_id = order_data.get("country_id", order_data.get("countryId", "0"))
        service_id = order_data.get("service_id", order_data.get("serviceId", "tg"))
        
        logger.info(f"Extracted: user_id={user_id}, country_id={country_id}, service_id={service_id}")
        
        # –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑ —Å –ª—é–±—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
        import time
        order_id = f"order_{int(time.time())}"
        
        new_order = {
            "id": order_id,
            "user_id": user_id,
            "country_id": str(country_id),
            "service_id": str(service_id),
            "phone_number": "+79001234567",  # –ú–æ–∫ –Ω–æ–º–µ—Ä
            "status": "pending",
            "cost": 15.0,
            "created_at": "2024-01-01T10:00:00Z",
            "messages": [],
            "success": True
        }
        
        logger.info(f"Successfully created order: {new_order}")
        return new_order
        
    except Exception as e:
        logger.error(f"Error creating order: {e}")
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        return {
            "success": True,
            "id": "order_fallback",
            "user_id": "sample_user",
            "country_id": "0",
            "service_id": "tg",
            "phone_number": "+79001234567",
            "status": "pending",
            "cost": 15.0,
            "created_at": "2024-01-01T10:00:00Z",
            "messages": [],
            "error_info": str(e)
        }

@router.get("/orders/{order_id}")
async def get_order(order_id: str) -> Dict[str, Any]:
    """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–∫–∞–∑–µ"""
    try:
        logger.info(f"Getting order: {order_id}")
        
        # –ú–æ–∫ –¥–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑–∞
        return {
            "id": order_id,
            "user_id": "sample_user", 
            "country_id": "0",
            "service_id": "tg",
            "phone_number": "+79001234567",
            "status": "pending",
            "cost": 15.0,
            "created_at": "2024-01-01T10:00:00Z",
            "messages": []
        }
        
    except Exception as e:
        logger.error(f"Error getting order {order_id}: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.delete("/orders/{order_id}")
async def cancel_order(order_id: str) -> Dict[str, Any]:
    """–û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–∫–∞–∑"""
    try:
        logger.info(f"Cancelling order: {order_id}")
        
        return {
            "id": order_id,
            "status": "cancelled",
            "message": "Order cancelled successfully"
        }
        
    except Exception as e:
        logger.error(f"Error cancelling order {order_id}: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/health")
async def health_check() -> Dict[str, Any]:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è API"""
    return {
        "status": "ok",
        "message": "OnlineSim API is running",
        "version": "1.0.0"
    }

================================================================================
FILE: app\api\sse.py
================================================================================

import asyncio
import json
import logging
from typing import Dict, List, Any, Optional
from fastapi import Request
from fastapi.responses import StreamingResponse
from ..schemas.schemas import SSEEvent

logger = logging.getLogger(__name__)

class SSEManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è Server-Sent Events"""
    
    def __init__(self):
        self.connections: Dict[str, List[asyncio.Queue]] = {}
    
    async def connect(self, user_id: str) -> asyncio.Queue:
        """–ü–æ–¥–∫–ª—é—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫ SSE"""
        queue = asyncio.Queue()
        
        if user_id not in self.connections:
            self.connections[user_id] = []
        
        self.connections[user_id].append(queue)
        logger.info(f"SSE connection added for user {user_id}")
        
        return queue
    
    async def disconnect(self, user_id: str, queue: asyncio.Queue):
        """–û—Ç–∫–ª—é—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ—Ç SSE"""
        if user_id in self.connections:
            try:
                self.connections[user_id].remove(queue)
                if not self.connections[user_id]:
                    del self.connections[user_id]
                logger.info(f"SSE connection removed for user {user_id}")
            except ValueError:
                pass
    
    async def send_to_user(self, user_id: str, event_type: str, data: Dict[str, Any]):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        if user_id not in self.connections:
            logger.debug(f"No SSE connections for user {user_id}")
            return
        
        event = SSEEvent(type=event_type, data=data)
        message = self._format_sse_message(event)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤–æ –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        disconnected_queues = []
        for queue in self.connections[user_id]:
            try:
                await queue.put(message)
            except Exception as e:
                logger.error(f"Error sending SSE message: {e}")
                disconnected_queues.append(queue)
        
        # –£–¥–∞–ª—è–µ–º –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        for queue in disconnected_queues:
            await self.disconnect(user_id, queue)
        
        logger.debug(f"SSE event sent to user {user_id}: {event_type}")
    
    async def broadcast(self, event_type: str, data: Dict[str, Any]):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –≤—Å–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"""
        event = SSEEvent(type=event_type, data=data)
        message = self._format_sse_message(event)
        
        for user_id in list(self.connections.keys()):
            await self.send_to_user(user_id, event_type, data)
        
        logger.debug(f"SSE event broadcasted: {event_type}")
    
    def _format_sse_message(self, event: SSEEvent) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ SSE"""
        data_json = json.dumps(event.data, ensure_ascii=False)
        return f"event: {event.type}\ndata: {data_json}\n\n"
    
    def get_connection_count(self, user_id: str) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return len(self.connections.get(user_id, []))
    
    def get_total_connections(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π"""
        return sum(len(queues) for queues in self.connections.values())

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –º–µ–Ω–µ–¥–∂–µ—Ä–∞
sse_manager = SSEManager()

async def create_sse_stream(request: Request, user_id: str):
    """–°–æ–∑–¥–∞—Ç—å –ø–æ—Ç–æ–∫ SSE –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    
    async def event_stream():
        queue = await sse_manager.connect(user_id)
        
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            welcome_message = sse_manager._format_sse_message(
                SSEEvent(
                    type="connected",
                    data={
                        "message": "SSE connection established",
                        "timestamp": str(asyncio.get_event_loop().time())
                    }
                )
            )
            yield welcome_message
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º keep-alive –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
            keep_alive_task = asyncio.create_task(send_keep_alive(queue))
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏—è
            while True:
                try:
                    # –ñ–¥–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
                    message = await asyncio.wait_for(queue.get(), timeout=1.0)
                    yield message
                    
                except asyncio.TimeoutError:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–∫–ª—é—á–∏–ª—Å—è –ª–∏ –∫–ª–∏–µ–Ω—Ç
                    if await request.is_disconnected():
                        break
                    continue
                    
                except Exception as e:
                    logger.error(f"Error in SSE stream: {e}")
                    break
            
        except Exception as e:
            logger.error(f"Error in SSE event stream: {e}")
            
        finally:
            # –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏
            keep_alive_task.cancel()
            await sse_manager.disconnect(user_id, queue)
    
    return event_stream()

async def send_keep_alive(queue: asyncio.Queue):
    """–û—Ç–ø—Ä–∞–≤–ª—è—Ç—å keep-alive —Å–æ–æ–±—â–µ–Ω–∏—è"""
    try:
        while True:
            await asyncio.sleep(30)  # –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
            
            keep_alive_message = sse_manager._format_sse_message(
                SSEEvent(
                    type="keep_alive",
                    data={"timestamp": str(asyncio.get_event_loop().time())}
                )
            )
            
            await queue.put(keep_alive_message)
            
    except asyncio.CancelledError:
        pass
    except Exception as e:
        logger.error(f"Error in keep-alive task: {e}")

def create_sse_response(request: Request, user_id: str) -> StreamingResponse:
    """–°–æ–∑–¥–∞—Ç—å SSE response"""
    return StreamingResponse(
        create_sse_stream(request, user_id),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Headers": "Cache-Control"
        }
    )

================================================================================
FILE: app\api\__init__.py
================================================================================



================================================================================
FILE: app\core\config.py
================================================================================

from pydantic_settings import BaseSettings
from typing import List
import os

class Settings(BaseSettings):
    # Database - –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ URL
    #database_url: str = "sqlite:///./onlinesim.db"
    async_database_url: str = "sqlite+aiosqlite:///./onlinesim.db"
    database_echo: bool = False
    
    # FastAPI
    secret_key: str = "your-secret-key-here"
    debug: bool = True
    cors_origins: List[str] = ["http://localhost:5173", "http://localhost:3000"]
    
    # SMS Service
    sms_provider: str = "dummy"
    sms_api_key: str = ""
    sms_api_url: str = "https://api.sms-service.com"
    sms_webhook_secret: str = "webhook-secret-key"
    
    # Order Settings
    order_timeout_minutes: int = 15
    api_timeout_seconds: int = 30
    retry_attempts: int = 3
    
    # Telegram Bot
    telegram_bot_token: str = ""
    telegram_webhook_url: str = ""
    webapp_url: str = "http://localhost:3000"
    
    # CORS
    @property
    def CORS_ORIGINS(self) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö CORS origins"""
        origins = os.getenv("CORS_ORIGINS", "http://localhost:5173,http://localhost:3000")
        return [origin.strip() for origin in origins.split(",") if origin.strip()]
    
    # Server
    host: str = "0.0.0.0"
    port: int = 8000
    frontend_port: int = 3000
    
    # Logging
    log_level: str = "INFO"
    
    class Config:
        env_file = ".env"
        case_sensitive = False

settings = Settings()

================================================================================
FILE: app\core\database.py
================================================================================

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from .config import settings

# –°–æ–∑–¥–∞–Ω–∏–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –¥–≤–∏–∂–∫–∞
engine = create_async_engine(
    settings.async_database_url,
    echo=settings.database_echo,
    future=True
)

# –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Å–µ—Å—Å–∏—è
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False,
    autocommit=False
)

Base = declarative_base()

async def get_async_db():
    """–ü–æ–ª—É—á–∏—Ç—å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é —Å–µ—Å—Å–∏—é –ë–î"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

async def create_tables():
    """–°–æ–∑–¥–∞—Ç—å —Ç–∞–±–ª–∏—Ü—ã –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def drop_tables():
    """–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã (–¥–ª—è —Ç–µ—Å—Ç–æ–≤)"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

================================================================================
FILE: app\core\__init__.py
================================================================================



================================================================================
FILE: app\models\models.py
================================================================================

from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from ..core.database import Base

class Country(Base):
    __tablename__ = "countries"
    
    id = Column(String, primary_key=True)
    name = Column(Text, nullable=False)
    code = Column(Text, nullable=False, unique=True)
    flag = Column(Text, nullable=False)
    price_from = Column(Integer, nullable=False)
    available = Column(Boolean, nullable=False, default=True)
    numbers_count = Column(Integer, nullable=False, default=0)
    status = Column(Text, nullable=False, default="available")  # available, low, unavailable

class Service(Base):
    __tablename__ = "services"
    
    id = Column(String, primary_key=True)
    name = Column(Text, nullable=False)
    icon = Column(Text, nullable=False)
    price_from = Column(Integer, nullable=False)
    price_to = Column(Integer, nullable=False)
    available = Column(Boolean, nullable=False, default=True)

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(String, primary_key=True)
    phone_number = Column(Text, nullable=False)
    country_id = Column(String, ForeignKey("countries.id"), nullable=False)
    service_id = Column(String, ForeignKey("services.id"), nullable=False)
    user_telegram_id = Column(String, ForeignKey("users.telegram_id"), nullable=False)
    price = Column(Integer, nullable=False)
    status = Column(Text, nullable=False, default="pending")  # pending, received, expired, cancelled
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, nullable=False, default=func.now())
    
    # SMS service specific fields
    external_order_id = Column(String, nullable=True)  # ID –æ—Ç SMS —Å–µ—Ä–≤–∏—Å–∞
    
    # Relationships
    country = relationship("Country")
    service = relationship("Service")
    user = relationship("User")
    messages = relationship("Message", back_populates="order")

class Message(Base):
    __tablename__ = "messages"
    
    id = Column(String, primary_key=True)
    order_id = Column(String, ForeignKey("orders.id"), nullable=False)
    text = Column(Text, nullable=False)
    code = Column(Text, nullable=True)
    received_at = Column(DateTime, nullable=False, default=func.now())
    
    # Relationship
    order = relationship("Order", back_populates="messages")

class User(Base):
    __tablename__ = "users"
    
    id = Column(String, primary_key=True)
    telegram_id = Column(String, nullable=False, unique=True, index=True)
    username = Column(Text, nullable=True)
    first_name = Column(Text, nullable=True)
    last_name = Column(Text, nullable=True)
    balance = Column(Integer, nullable=False, default=0)  # in kopecks
    is_admin = Column(Boolean, nullable=False, default=False)
    created_at = Column(DateTime, nullable=False, default=func.now())
    
    # Relationships
    orders = relationship("Order")

class Setting(Base):
    __tablename__ = "settings"
    
    id = Column(String, primary_key=True)
    key = Column(Text, nullable=False, unique=True)
    value = Column(Text, nullable=False)
    description = Column(Text, nullable=True)
    updated_at = Column(DateTime, nullable=False, default=func.now(), onupdate=func.now())

class Statistic(Base):
    __tablename__ = "statistics"
    
    id = Column(String, primary_key=True)
    date = Column(Text, nullable=False, unique=True)  # YYYY-MM-DD
    total_orders = Column(Integer, nullable=False, default=0)
    total_revenue = Column(Integer, nullable=False, default=0)  # in kopecks
    new_users = Column(Integer, nullable=False, default=0)
    active_users = Column(Integer, nullable=False, default=0)

================================================================================
FILE: app\models\__init__.py
================================================================================



================================================================================
FILE: app\schemas\schemas.py
================================================================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List
from enum import Enum

# Enums
class OrderStatus(str, Enum):
    PENDING = "pending"
    RECEIVED = "received" 
    EXPIRED = "expired"
    CANCELLED = "cancelled"

class CountryStatus(str, Enum):
    AVAILABLE = "available"
    LOW = "low"
    UNAVAILABLE = "unavailable"

# Base schemas
class CountryBase(BaseModel):
    name: str
    code: str
    flag: str
    price_from: int
    available: bool = True
    numbers_count: int = 0
    status: CountryStatus = CountryStatus.AVAILABLE

class Country(CountryBase):
    id: str
    
    class Config:
        from_attributes = True

class ServiceBase(BaseModel):
    name: str
    icon: str
    price_from: int
    price_to: int
    available: bool = True

class Service(ServiceBase):
    id: str
    
    class Config:
        from_attributes = True

class OrderBase(BaseModel):
    phone_number: str
    country_id: str
    service_id: str
    price: int
    status: OrderStatus = OrderStatus.PENDING

class OrderCreate(BaseModel):
    country_id: str
    service_id: str
    telegram_id: str

class Order(OrderBase):
    id: str
    user_telegram_id: str
    expires_at: datetime
    created_at: datetime
    external_order_id: Optional[str] = None
    
    # Relationships
    country: Optional[Country] = None
    service: Optional[Service] = None
    
    class Config:
        from_attributes = True

class MessageBase(BaseModel):
    text: str
    code: Optional[str] = None

class MessageCreate(MessageBase):
    order_id: str

class Message(MessageBase):
    id: str
    order_id: str
    received_at: datetime
    
    class Config:
        from_attributes = True

class UserBase(BaseModel):
    telegram_id: str
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    balance: int = 0
    is_admin: bool = False

class UserCreate(UserBase):
    pass

class User(UserBase):
    id: str
    created_at: datetime
    
    class Config:
        from_attributes = True

class SettingBase(BaseModel):
    key: str
    value: str
    description: Optional[str] = None

class SettingCreate(SettingBase):
    pass

class SettingUpdate(BaseModel):
    value: str

class Setting(SettingBase):
    id: str
    updated_at: datetime
    
    class Config:
        from_attributes = True

class StatisticBase(BaseModel):
    date: str  # YYYY-MM-DD
    total_orders: int = 0
    total_revenue: int = 0
    new_users: int = 0
    active_users: int = 0

class StatisticCreate(StatisticBase):
    pass

class Statistic(StatisticBase):
    id: str
    
    class Config:
        from_attributes = True

# Response schemas
class OrderResponse(Order):
    messages: List[Message] = []

# Webhook schemas
class SMSWebhookData(BaseModel):
    order_id: str
    phone_number: str
    message_text: str
    code: Optional[str] = None
    timestamp: datetime

# SSE Event schemas  
class SSEEvent(BaseModel):
    type: str
    data: dict

class OrderStatusUpdate(BaseModel):
    order_id: str
    status: OrderStatus
    message: Optional[str] = None

class SMSReceived(BaseModel):
    order_id: str
    message: Message

================================================================================
FILE: app\schemas\__init__.py
================================================================================



================================================================================
FILE: app\services\order_service.py
================================================================================

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Optional, List
from sqlalchemy.orm import Session
from sqlalchemy import and_
from ..core.config import settings
from ..models.models import Order, User, Country, Service, Message
from ..schemas.schemas import OrderCreate, OrderStatus
from .sms.adapter import SMSProviderFactory

logger = logging.getLogger(__name__)

class OrderService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞–∫–∞–∑–∞–º–∏"""
    
    def __init__(self):
        self.sms_provider = None
        self._init_sms_provider()
    
    def _init_sms_provider(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"""
        try:
            self.sms_provider = SMSProviderFactory.create_provider(
                settings.sms_provider,
                api_key=settings.sms_api_key,
                api_url=settings.sms_api_url
            )
            logger.info(f"SMS provider initialized: {settings.sms_provider}")
        except Exception as e:
            logger.error(f"Failed to initialize SMS provider: {e}")
    
    async def create_order(self, db: Session, order_data: OrderCreate) -> Optional[Order]:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user = db.query(User).filter(User.telegram_id == order_data.telegram_id).first()
            if not user:
                logger.error(f"User not found: {order_data.telegram_id}")
                return None
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–∞–Ω—É –∏ —Å–µ—Ä–≤–∏—Å
            country = db.query(Country).filter(Country.id == order_data.country_id).first()
            service = db.query(Service).filter(Service.id == order_data.service_id).first()
            
            if not country or not service:
                logger.error("Country or service not found")
                return None
            
            if not country.available or not service.available:
                logger.error("Country or service not available")
                return None
            
            # –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—É
            price = max(country.price_from, service.price_from)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
            if user.balance < price:
                logger.error(f"Insufficient balance: {user.balance} < {price}")
                return None
            
            # –ó–∞–∫–∞–∑—ã–≤–∞–µ–º –Ω–æ–º–µ—Ä —á–µ—Ä–µ–∑ SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
            sms_result = await self._order_phone_number(country.code, service.name)
            if not sms_result or not sms_result.success:
                logger.error(f"Failed to order phone number: {sms_result.error_message if sms_result else 'Unknown error'}")
                return None
            
            # –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑
            order = Order(
                id=self._generate_id(),
                phone_number=sms_result.phone_number,
                country_id=order_data.country_id,
                service_id=order_data.service_id,
                user_telegram_id=order_data.telegram_id,
                price=price,
                status=OrderStatus.PENDING.value,
                expires_at=datetime.now() + timedelta(minutes=settings.order_timeout_minutes),
                external_order_id=sms_result.external_order_id
            )
            
            # –°–ø–∏—Å—ã–≤–∞–µ–º –¥–µ–Ω—å–≥–∏ —Å –±–∞–ª–∞–Ω—Å–∞
            user.balance -= price
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
            db.add(order)
            db.commit()
            db.refresh(order)
            
            logger.info(f"Order created: {order.id}, phone: {order.phone_number}")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏—Å—Ç–µ—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
            asyncio.create_task(self._monitor_order_expiration(order.id))
            
            return order
            
        except Exception as e:
            logger.error(f"Error creating order: {e}")
            db.rollback()
            return None
    
    async def cancel_order(self, db: Session, order_id: str, user_telegram_id: str) -> bool:
        """–û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–∫–∞–∑"""
        try:
            order = db.query(Order).filter(
                and_(
                    Order.id == order_id,
                    Order.user_telegram_id == user_telegram_id,
                    Order.status == OrderStatus.PENDING.value
                )
            ).first()
            
            if not order:
                logger.warning(f"Order not found or cannot be cancelled: {order_id}")
                return False
            
            # –û—Ç–º–µ–Ω—è–µ–º –∑–∞–∫–∞–∑ –≤ SMS —Å–µ—Ä–≤–∏—Å–µ
            if order.external_order_id and self.sms_provider:
                try:
                    await self.sms_provider.cancel_order(order.external_order_id)
                except Exception as e:
                    logger.warning(f"Failed to cancel order in SMS service: {e}")
            
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ–Ω—å–≥–∏
            user = db.query(User).filter(User.telegram_id == user_telegram_id).first()
            if user:
                user.balance += order.price
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
            order.status = OrderStatus.CANCELLED.value
            
            db.commit()
            logger.info(f"Order cancelled: {order_id}")
            
            # –£–≤–µ–¥–æ–º–ª—è–µ–º —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥
            await self._notify_order_status_change(order, "–ó–∞–∫–∞–∑ –æ—Ç–º–µ–Ω–µ–Ω")
            
            return True
            
        except Exception as e:
            logger.error(f"Error cancelling order: {e}")
            db.rollback()
            return False
    
    async def get_user_orders(self, db: Session, user_telegram_id: str) -> List[Order]:
        """–ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return db.query(Order).filter(
            Order.user_telegram_id == user_telegram_id
        ).order_by(Order.created_at.desc()).all()
    
    async def get_active_orders(self, db: Session) -> List[Order]:
        """–ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–∫–∞–∑—ã"""
        return db.query(Order).filter(
            Order.status == OrderStatus.PENDING.value
        ).all()
    
    async def _order_phone_number(self, country_code: str, service_name: str):
        """–ó–∞–∫–∞–∑–∞—Ç—å –Ω–æ–º–µ—Ä —á–µ—Ä–µ–∑ SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"""
        if not self.sms_provider:
            logger.error("SMS provider not initialized")
            return None
        
        try:
            service_code = self.sms_provider.map_service_name_to_code(service_name)
            country_code = self.sms_provider.map_country_code(country_code)
            
            return await self.sms_provider.order_number(country_code, service_code)
            
        except Exception as e:
            logger.error(f"Error ordering phone number: {e}")
            return None
    
    async def _monitor_order_expiration(self, order_id: str):
        """–û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –∏—Å—Ç–µ—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–∫–∞–∑–∞"""
        try:
            # –ñ–¥–µ–º –≤—Ä–µ–º—è –∏—Å—Ç–µ—á–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞
            await asyncio.sleep(settings.order_timeout_minutes * 60)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–∫–∞–∑
            db = next(self._get_db())
            try:
                order = db.query(Order).filter(Order.id == order_id).first()
                if not order:
                    return
                
                # –ï—Å–ª–∏ –∑–∞–∫–∞–∑ –≤—Å–µ –µ—â–µ pending, –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ expired –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ–Ω—å–≥–∏
                if order.status == OrderStatus.PENDING.value:
                    await self._expire_order(db, order)
                    
            finally:
                db.close()
                
        except Exception as e:
            logger.error(f"Error monitoring order expiration: {e}")
    
    async def _expire_order(self, db: Session, order: Order):
        """–ü–æ–º–µ—Ç–∏—Ç—å –∑–∞–∫–∞–∑ –∫–∞–∫ –∏—Å—Ç–µ–∫—à–∏–π –∏ –≤–µ—Ä–Ω—É—Ç—å –¥–µ–Ω—å–≥–∏"""
        try:
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ–Ω—å–≥–∏
            user = db.query(User).filter(User.telegram_id == order.user_telegram_id).first()
            if user:
                user.balance += order.price
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
            order.status = OrderStatus.EXPIRED.value
            
            # –û—Ç–º–µ–Ω—è–µ–º –∑–∞–∫–∞–∑ –≤ SMS —Å–µ—Ä–≤–∏—Å–µ
            if order.external_order_id and self.sms_provider:
                try:
                    await self.sms_provider.cancel_order(order.external_order_id)
                except Exception as e:
                    logger.warning(f"Failed to cancel expired order in SMS service: {e}")
            
            db.commit()
            logger.info(f"Order expired: {order.id}")
            
            # –£–≤–µ–¥–æ–º–ª—è–µ–º —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥
            await self._notify_order_status_change(order, "–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∏—Å—Ç–µ–∫–ª–æ, –¥–µ–Ω—å–≥–∏ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã")
            
        except Exception as e:
            logger.error(f"Error expiring order: {e}")
            db.rollback()
    
    async def _notify_order_status_change(self, order: Order, message: str):
        """–£–≤–µ–¥–æ–º–∏—Ç—å –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫–∞–∑–∞"""
        try:
            from ..api.sse import sse_manager
            
            await sse_manager.send_to_user(
                user_id=order.user_telegram_id,
                event_type="order_status_updated",
                data={
                    "order_id": order.id,
                    "status": order.status,
                    "message": message
                }
            )
        except Exception as e:
            logger.error(f"Error sending order status notification: {e}")
    
    def _generate_id(self) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID"""
        import uuid
        return str(uuid.uuid4())
    
    def _get_db(self):
        """–ü–æ–ª—É—á–∏—Ç—å —Å–µ—Å—Å–∏—é –ë–î"""
        from ..core.database import get_db
        return get_db()

# –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –∑–∞–¥–∞—á–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –∏—Å—Ç–µ–∫—à–∏—Ö –∑–∞–∫–∞–∑–æ–≤
class OrderCleanupService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –∏—Å—Ç–µ–∫—à–∏—Ö –∑–∞–∫–∞–∑–æ–≤"""
    
    @staticmethod
    async def cleanup_expired_orders():
        """–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–µ–∫—à–∏–µ –∑–∞–∫–∞–∑—ã"""
        db = next(get_db())
        try:
            expired_orders = db.query(Order).filter(
                and_(
                    Order.status == OrderStatus.PENDING.value,
                    Order.expires_at < datetime.now()
                )
            ).all()
            
            order_service = OrderService()
            for order in expired_orders:
                await order_service._expire_order(db, order)
                
            if expired_orders:
                logger.info(f"Cleaned up {len(expired_orders)} expired orders")
                
        except Exception as e:
            logger.error(f"Error in cleanup task: {e}")
        finally:
            db.close()

# –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫—É—é –æ—á–∏—Å—Ç–∫—É
async def start_cleanup_task():
    """–ó–∞–ø—É—Å—Ç–∏—Ç—å –∑–∞–¥–∞—á—É –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–∏"""
    while True:
        try:
            await OrderCleanupService.cleanup_expired_orders()
            await asyncio.sleep(60)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
        except Exception as e:
            logger.error(f"Error in cleanup task loop: {e}")
            await asyncio.sleep(60)

================================================================================
FILE: app\services\user_service.py
================================================================================

import logging
from datetime import datetime
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from ..models.models import User
from ..schemas.schemas import UserCreate
from ..utils.telegram import validate_telegram_init_data

logger = logging.getLogger(__name__)

class UserService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ (async)"""
    
    @staticmethod
    async def get_user_by_telegram_id(db: AsyncSession, telegram_id: str) -> Optional[User]:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
        result = await db.execute(
            select(User).where(User.telegram_id == telegram_id)
        )
        return result.scalars().first()
    
    @staticmethod
    async def create_user(db: AsyncSession, user_data: UserCreate) -> Optional[User]:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
            existing_user = await UserService.get_user_by_telegram_id(db, user_data.telegram_id)
            if existing_user:
                logger.info(f"User already exists: {user_data.telegram_id}")
                return existing_user
            
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user = User(
                id=UserService._generate_id(),
                telegram_id=user_data.telegram_id,
                username=user_data.username,
                first_name=user_data.first_name,
                last_name=user_data.last_name,
                balance=user_data.balance or 0,
                is_admin=user_data.is_admin or False
            )
            
            db.add(user)
            await db.commit()
            await db.refresh(user)
            
            logger.info(f"User created: {user.telegram_id}")
            return user
            
        except Exception as e:
            logger.error(f"Error creating user: {e}")
            await db.rollback()
            return None
    
    @staticmethod
    async def update_user_balance(db: AsyncSession, telegram_id: str, new_balance: int) -> Optional[User]:
        """–û–±–Ω–æ–≤–∏—Ç—å –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ"""
        try:
            user = await UserService.get_user_by_telegram_id(db, telegram_id)
            if not user:
                logger.error(f"User not found for balance update: {telegram_id}")
                return None
            
            old_balance = user.balance
            user.balance = new_balance
            
            await db.commit()
            await db.refresh(user)
            
            logger.info(f"User balance updated: {telegram_id}, {old_balance} -> {new_balance}")
            return user
            
        except Exception as e:
            logger.error(f"Error updating user balance: {e}")
            await db.rollback()
            return None
    
    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Å async/await...
    
    @staticmethod
    def _generate_id() -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID"""
        import uuid
        return str(uuid.uuid4())

================================================================================
FILE: app\services\__init__.py
================================================================================



================================================================================
FILE: app\services\sms\adapter.py
================================================================================

import logging
from typing import Optional, Dict, Any
from .providers.base_provider import BaseSMSProvider
from .providers.dummy_provider import DummyProvider

logger = logging.getLogger(__name__)

class SMSAdapter:
    """–ê–¥–∞–ø—Ç–µ—Ä –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞–º–∏"""
    
    def __init__(self, provider_name: str = "dummy", api_key: Optional[str] = None):
        self.provider_name = provider_name.lower()
        self.api_key = api_key
        self.provider = self._initialize_provider()
        
    def _initialize_provider(self) -> BaseSMSProvider:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"""
        try:
            if self.provider_name == "dummy":
                logger.info("Initializing dummy SMS provider")
                return DummyProvider(api_key=self.api_key)
            else:
                logger.error(f"Unknown SMS provider: {self.provider_name}")
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º dummy provider –∫–∞–∫ fallback
                logger.info("Falling back to dummy SMS provider")
                return DummyProvider(api_key=self.api_key)
                
        except Exception as e:
            logger.error(f"Failed to initialize SMS provider {self.provider_name}: {e}")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º dummy provider –∫–∞–∫ fallback
            logger.info("Falling back to dummy SMS provider")
            return DummyProvider(api_key=self.api_key)
    
    async def get_number(self, country_id: str, service_id: str) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
        try:
            return await self.provider.get_number(country_id, service_id)
        except Exception as e:
            logger.error(f"Error getting number: {e}")
            return None
    
    async def get_sms(self, order_id: str) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å SMS —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            return await self.provider.get_sms(order_id)
        except Exception as e:
            logger.error(f"Error getting SMS: {e}")
            return None
    
    async def cancel_number(self, order_id: str) -> bool:
        """–û—Ç–º–µ–Ω–∏—Ç—å –Ω–æ–º–µ—Ä"""
        try:
            return await self.provider.cancel_number(order_id)
        except Exception as e:
            logger.error(f"Error cancelling number: {e}")
            return False
    
    async def get_balance(self) -> Optional[float]:
        """–ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å"""
        try:
            return await self.provider.get_balance()
        except Exception as e:
            logger.error(f"Error getting balance: {e}")
            return None
    
    async def get_countries(self) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω"""
        try:
            return await self.provider.get_countries()
        except Exception as e:
            logger.error(f"Error getting countries: {e}")
            return None
    
    async def get_services(self) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–∏—Å–æ–≤"""
        try:
            return await self.provider.get_services()
        except Exception as e:
            logger.error(f"Error getting services: {e}")
            return None

# –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
class SMSProviderFactory:
    """–§–∞–±—Ä–∏–∫–∞ SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)"""
    
    @staticmethod
    def create_provider(provider_name: str = "dummy", api_key: Optional[str] = None, **kwargs) -> SMSAdapter:
        """–°–æ–∑–¥–∞—Ç—å SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"""
        # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ª–∏—à–Ω–∏–µ kwargs –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        return SMSAdapter(provider_name=provider_name, api_key=api_key)

================================================================================
FILE: app\services\sms\validator.py
================================================================================

import re
import logging
from datetime import datetime
from typing import Optional, Dict, Any
from ...schemas.schemas import SMSWebhookData, Message

logger = logging.getLogger(__name__)

class SMSValidator:
    """–í–∞–ª–∏–¥–∞—Ç–æ—Ä SMS –¥–∞–Ω–Ω—ã—Ö - –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –≤–æ —Ñ—Ä–æ–Ω—Ç"""
    
    @staticmethod
    def extract_verification_code(message_text: str) -> Optional[str]:
        """–ò–∑–≤–ª–µ—á—å –∫–æ–¥ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏–∑ SMS —Ç–µ–∫—Å—Ç–∞"""
        if not message_text:
            return None
        
        # –†–∞–∑–ª–∏—á–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ–¥–∞
        patterns = [
            r'\b(\d{4,6})\b',  # 4-6 —Ü–∏—Ñ—Ä –ø–æ–¥—Ä—è–¥
            r'–∫–æ–¥:?\s*(\d+)',  # "–∫–æ–¥: 12345"
            r'code:?\s*(\d+)',  # "code: 12345" 
            r'verification:?\s*(\d+)',  # "verification: 12345"
            r'confirm:?\s*(\d+)',  # "confirm: 12345"
            r'your\s+code:?\s*(\d+)',  # "your code: 12345"
            r'(\d+)\s+is\s+your',  # "12345 is your code"
            r'(\d{4,6})\D',  # 4-6 —Ü–∏—Ñ—Ä —Å –Ω–µ-—Ü–∏—Ñ—Ä–æ–π –ø–æ—Å–ª–µ
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, message_text, re.IGNORECASE)
            for match in matches:
                if isinstance(match, tuple):
                    match = match[0]
                if 4 <= len(match) <= 6 and match.isdigit():
                    logger.info(f"Extracted code '{match}' from message: {message_text}")
                    return match
        
        logger.warning(f"No verification code found in message: {message_text}")
        return None
    
    @staticmethod
    def validate_phone_number(phone_number: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
        if not phone_number:
            return False
        
        # –£–±–∏—Ä–∞–µ–º –≤—Å–µ –∫—Ä–æ–º–µ —Ü–∏—Ñ—Ä –∏ +
        clean_number = re.sub(r'[^\d+]', '', phone_number)
        
        # –î–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å + –∏ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ—Ç 10 –¥–æ 15 —Ü–∏—Ñ—Ä
        pattern = r'^\+\d{10,15}'
        is_valid = bool(re.match(pattern, clean_number))
        
        if not is_valid:
            logger.warning(f"Invalid phone number format: {phone_number}")
        
        return is_valid
    
    @staticmethod
    def sanitize_message_text(message_text: str) -> str:
        """–û—á–∏—Å—Ç–∏—Ç—å —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ª–∏—à–Ω–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤"""
        if not message_text:
            return ""
        
        # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –∏ –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫
        cleaned = re.sub(r'\s+', ' ', message_text.strip())
        
        # –£–±–∏—Ä–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç —Å–ª–æ–º–∞—Ç—å JSON
        cleaned = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', cleaned)
        
        return cleaned
    
    @staticmethod
    def validate_webhook_data(data: Dict[str, Any]) -> Optional[SMSWebhookData]:
        """–í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –≤–µ–±—Ö—É–∫–∞ –æ—Ç SMS —Å–µ—Ä–≤–∏—Å–∞"""
        try:
            # –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
            required_fields = ['order_id', 'phone_number', 'message_text']
            for field in required_fields:
                if field not in data or not data[field]:
                    logger.error(f"Missing required field in webhook data: {field}")
                    return None
            
            # –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞
            if not SMSValidator.validate_phone_number(data['phone_number']):
                logger.error(f"Invalid phone number in webhook: {data['phone_number']}")
                return None
            
            # –û—á–∏—Å—Ç–∫–∞ –∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–¥–∞
            message_text = SMSValidator.sanitize_message_text(data['message_text'])
            code = SMSValidator.extract_verification_code(message_text)
            
            # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç —Å –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            webhook_data = SMSWebhookData(
                order_id=str(data['order_id']),
                phone_number=data['phone_number'],
                message_text=message_text,
                code=code,
                timestamp=data.get('timestamp', datetime.now())
            )
            
            logger.info(f"Successfully validated webhook data for order: {webhook_data.order_id}")
            return webhook_data
            
        except Exception as e:
            logger.error(f"Error validating webhook data: {e}")
            return None
    
    @staticmethod
    def prepare_frontend_message(order_id: str, message_text: str, code: Optional[str] = None) -> Dict[str, Any]:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤–æ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥"""
        
        # –ï—Å–ª–∏ –∫–æ–¥ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω, –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å
        if not code:
            code = SMSValidator.extract_verification_code(message_text)
        
        # –û—á–∏—â–∞–µ–º —Ç–µ–∫—Å—Ç
        clean_text = SMSValidator.sanitize_message_text(message_text)
        
        frontend_data = {
            "order_id": order_id,
            "message_text": clean_text,
            "code": code,
            "has_code": bool(code),
            "received_at": datetime.now().isoformat(),
            "status": "received"
        }
        
        logger.info(f"Prepared frontend message for order {order_id}: code={'found' if code else 'not found'}")
        return frontend_data
    
    @staticmethod
    def validate_order_status_transition(current_status: str, new_status: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –ø–µ—Ä–µ—Ö–æ–¥–∞ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫–∞–∑–∞"""
        
        valid_transitions = {
            "pending": ["received", "expired", "cancelled"],
            "received": [],  # –§–∏–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
            "expired": [],   # –§–∏–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
            "cancelled": []  # –§–∏–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
        }
        
        if current_status not in valid_transitions:
            logger.error(f"Invalid current status: {current_status}")
            return False
        
        if new_status not in valid_transitions[current_status]:
            logger.warning(f"Invalid status transition: {current_status} -> {new_status}")
            return False
        
        return True
    
    @staticmethod
    def is_message_duplicate(existing_messages: list, new_message_text: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥—É–±–ª–∏–∫–∞—Ç–æ–º"""
        if not existing_messages or not new_message_text:
            return False
        
        clean_new = SMSValidator.sanitize_message_text(new_message_text)
        
        for msg in existing_messages:
            if hasattr(msg, 'text'):
                existing_text = SMSValidator.sanitize_message_text(msg.text)
                if existing_text == clean_new:
                    logger.warning(f"Duplicate message detected: {clean_new}")
                    return True
        
        return False

================================================================================
FILE: app\services\sms\webhook.py
================================================================================

import asyncio
import logging
from typing import Dict, Any, Optional
from datetime import datetime
from sqlalchemy.orm import Session
from ...core.database import get_db
from ...models.models import Order, Message, User
from ...schemas.schemas import SMSWebhookData, OrderStatus, MessageCreate
from .validator import SMSValidator
from ..order_service import OrderService

logger = logging.getLogger(__name__)

class SMSWebhookHandler:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–µ–±—Ö—É–∫–æ–≤ –æ—Ç SMS —Å–µ—Ä–≤–∏—Å–æ–≤"""
    
    def __init__(self):
        self.order_service = OrderService()
    
    async def process_webhook(self, webhook_data: Dict[str, Any], provider_name: str = "unknown") -> bool:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–µ–±—Ö—É–∫–∞
        
        Args:
            webhook_data: –î–∞–Ω–Ω—ã–µ –æ—Ç SMS —Å–µ—Ä–≤–∏—Å–∞
            provider_name: –ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
            
        Returns:
            bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫–∏
        """
        try:
            logger.info(f"Processing webhook from {provider_name}: {webhook_data}")
            
            # –í–∞–ª–∏–¥–∏—Ä—É–µ–º –≤—Ö–æ–¥—è—â–∏–µ –¥–∞–Ω–Ω—ã–µ
            validated_data = SMSValidator.validate_webhook_data(webhook_data)
            if not validated_data:
                logger.error("Webhook data validation failed")
                return False
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–µ—Å—Å–∏—é –ë–î
            db = next(get_db())
            try:
                return await self._process_validated_webhook(db, validated_data, provider_name)
            finally:
                db.close()
                
        except Exception as e:
            logger.error(f"Error processing webhook: {e}")
            return False
    
    async def _process_validated_webhook(self, db: Session, data: SMSWebhookData, provider_name: str) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤–µ–±—Ö—É–∫–∞"""
        
        # –ò—â–µ–º –∑–∞–∫–∞–∑ –ø–æ ID –∏–ª–∏ –Ω–æ–º–µ—Ä—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞
        order = await self._find_order(db, data.order_id, data.phone_number)
        if not order:
            logger.warning(f"Order not found for webhook data: {data.order_id}, {data.phone_number}")
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–∫–∞–∑
        if not SMSValidator.validate_order_status_transition(order.status, "received"):
            logger.warning(f"Invalid status transition for order {order.id}: {order.status} -> received")
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã —Å–æ–æ–±—â–µ–Ω–∏–π
        existing_messages = db.query(Message).filter(Message.order_id == order.id).all()
        if SMSValidator.is_message_duplicate(existing_messages, data.message_text):
            logger.info(f"Duplicate message ignored for order {order.id}")
            return True
        
        # –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        message_data = MessageCreate(
            order_id=order.id,
            text=data.message_text,
            code=data.code
        )
        
        message = Message(
            id=self._generate_id(),
            order_id=message_data.order_id,
            text=message_data.text,
            code=message_data.code,
            received_at=datetime.now()
        )
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
        order.status = OrderStatus.RECEIVED.value
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
        db.add(message)
        db.commit()
        db.refresh(message)
        db.refresh(order)
        
        logger.info(f"SMS processed successfully for order {order.id}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤–æ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ —á–µ—Ä–µ–∑ SSE
        await self._notify_frontend(order, message)
        
        return True
    
    async def _find_order(self, db: Session, order_id: str, phone_number: str) -> Optional[Order]:
        """–ù–∞–π—Ç–∏ –∑–∞–∫–∞–∑ –ø–æ ID –∏–ª–∏ –Ω–æ–º–µ—Ä—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
        
        # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –ø–æ –ø—Ä—è–º–æ–º—É ID
        order = db.query(Order).filter(Order.id == order_id).first()
        if order:
            return order
        
        # –ó–∞—Ç–µ–º –ø–æ external_order_id (ID –æ—Ç SMS —Å–µ—Ä–≤–∏—Å–∞)
        order = db.query(Order).filter(Order.external_order_id == order_id).first()
        if order:
            return order
        
        # –í –∫—Ä–∞–π–Ω–µ–º —Å–ª—É—á–∞–µ –ø–æ –Ω–æ–º–µ—Ä—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ —Å—Ç–∞—Ç—É—Å—É pending
        order = db.query(Order).filter(
            Order.phone_number == phone_number,
            Order.status == OrderStatus.PENDING.value
        ).first()
        
        return order
    
    async def _notify_frontend(self, order: Order, message: Message):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤–æ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ —á–µ—Ä–µ–∑ SSE"""
        try:
            from ...api.sse import sse_manager
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
            frontend_data = SMSValidator.prepare_frontend_message(
                order_id=order.id,
                message_text=message.text,
                code=message.code
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            await sse_manager.send_to_user(
                user_id=order.user_telegram_id,
                event_type="sms_received",
                data=frontend_data
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫–∞–∑–∞
            await sse_manager.send_to_user(
                user_id=order.user_telegram_id,
                event_type="order_status_updated",
                data={
                    "order_id": order.id,
                    "status": order.status,
                    "message": "SMS –∫–æ–¥ –ø–æ–ª—É—á–µ–Ω!"
                }
            )
            
            logger.info(f"Frontend notifications sent for order {order.id}")
            
        except Exception as e:
            logger.error(f"Error sending frontend notification: {e}")
    
    def _generate_id(self) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID"""
        import uuid
        return str(uuid.uuid4())
    
    async def handle_provider_specific_webhook(self, provider_name: str, raw_data: Dict[str, Any]) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–µ–±—Ö—É–∫ –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"""
        
        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫—É—é –ª–æ–≥–∏–∫—É –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
        provider_handlers = {
            "dummy": self._handle_dummy_webhook,
            "smshub": self._handle_smshub_webhook,
            "5sim": self._handle_5sim_webhook,
        }
        
        handler = provider_handlers.get(provider_name, self._handle_generic_webhook)
        return await handler(raw_data)
    
    async def _handle_dummy_webhook(self, raw_data: Dict[str, Any]) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–µ–±—Ö—É–∫ –æ—Ç dummy –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"""
        # Dummy –ø—Ä–æ–≤–∞–π–¥–µ—Ä –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
        return await self.process_webhook(raw_data, "dummy")
    
    async def _handle_smshub_webhook(self, raw_data: Dict[str, Any]) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–µ–±—Ö—É–∫ –æ—Ç SMSHub"""
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ñ–æ—Ä–º–∞—Ç SMSHub –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π
        try:
            webhook_data = {
                "order_id": raw_data.get("id"),
                "phone_number": raw_data.get("phone"),
                "message_text": raw_data.get("text"),
                "timestamp": datetime.now()
            }
            return await self.process_webhook(webhook_data, "smshub")
        except Exception as e:
            logger.error(f"Error processing SMSHub webhook: {e}")
            return False
    
    async def _handle_5sim_webhook(self, raw_data: Dict[str, Any]) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–µ–±—Ö—É–∫ –æ—Ç 5sim"""
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ñ–æ—Ä–º–∞—Ç 5sim –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π
        try:
            webhook_data = {
                "order_id": raw_data.get("order_id"),
                "phone_number": raw_data.get("number"),
                "message_text": raw_data.get("sms"),
                "timestamp": datetime.now()
            }
            return await self.process_webhook(webhook_data, "5sim")
        except Exception as e:
            logger.error(f"Error processing 5sim webhook: {e}")
            return False
    
    async def _handle_generic_webhook(self, raw_data: Dict[str, Any]) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–µ–±—Ö—É–∫ –æ—Ç –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–≥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"""
        logger.warning(f"Using generic webhook handler for data: {raw_data}")
        return await self.process_webhook(raw_data, "generic")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Ä–æ—É—Ç–∞—Ö
webhook_handler = SMSWebhookHandler()

================================================================================
FILE: app\services\sms\__init__.py
================================================================================



================================================================================
FILE: app\services\sms\providers\base_provider.py
================================================================================

from abc import ABC, abstractmethod
from typing import Optional, Dict, Any
from dataclasses import dataclass

@dataclass
class SMSOrderResult:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–∫–∞–∑–∞ –Ω–æ–º–µ—Ä–∞"""
    success: bool
    order_id: Optional[str] = None
    phone_number: Optional[str] = None
    error_message: Optional[str] = None

@dataclass
class SMSStatusResult:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ SMS"""
    success: bool
    status: Optional[str] = None  # pending, received, expired
    messages: Optional[list] = None
    error_message: Optional[str] = None

class BaseSMSProvider(ABC):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤"""
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
    
    @abstractmethod
    async def get_number(self, country_id: str, service_id: str) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
        pass
    
    @abstractmethod
    async def get_sms(self, order_id: str) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å SMS —Å–æ–æ–±—â–µ–Ω–∏—è"""
        pass
    
    @abstractmethod
    async def cancel_number(self, order_id: str) -> bool:
        """–û—Ç–º–µ–Ω–∏—Ç—å –Ω–æ–º–µ—Ä"""
        pass
    
    @abstractmethod
    async def get_balance(self) -> Optional[float]:
        """–ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å"""
        pass
    
    @abstractmethod
    async def get_countries(self) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω"""
        pass
    
    @abstractmethod
    async def get_services(self) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–∏—Å–æ–≤"""
        pass

================================================================================
FILE: app\services\sms\providers\dummy_provider.py
================================================================================

import asyncio
import logging
from typing import Optional, Dict, Any
from datetime import datetime
from .base_provider import BaseSMSProvider

logger = logging.getLogger(__name__)

class DummyProvider(BaseSMSProvider):
    """Dummy SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"""
    
    def __init__(self, api_key: Optional[str] = None):
        super().__init__(api_key)
        self.orders = {}  # –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –∑–∞–∫–∞–∑–æ–≤
        
    async def get_number(self, country_id: str, service_id: str) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
        try:
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ñ–µ–π–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä
            order_id = f"dummy_order_{datetime.now().timestamp():.0f}"
            phone_number = f"+7900{datetime.now().microsecond % 1000000:06d}"
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–∫–∞–∑
            self.orders[order_id] = {
                "phone_number": phone_number,
                "status": "pending",
                "messages": [],
                "created_at": datetime.now()
            }
            
            logger.info(f"Generated dummy number: {phone_number} for order: {order_id}")
            
            return {
                "success": True,
                "order_id": order_id,
                "phone_number": phone_number,
                "cost": 15.0
            }
            
        except Exception as e:
            logger.error(f"Error in dummy get_number: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_sms(self, order_id: str) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å SMS —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            if order_id not in self.orders:
                return {
                    "success": False,
                    "error": "Order not found"
                }
            
            order = self.orders[order_id]
            
            # –ò–º–∏—Ç–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ SMS —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è
            if not order["messages"] and order["status"] == "pending":
                # –ü–æ—Å–ª–µ 10 —Å–µ–∫—É–Ω–¥ –¥–æ–±–∞–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ SMS
                elapsed = (datetime.now() - order["created_at"]).total_seconds()
                if elapsed > 10:
                    test_message = {
                        "text": f"–í–∞—à –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: {12345}",
                        "received_at": datetime.now().isoformat(),
                        "code": "12345"
                    }
                    order["messages"].append(test_message)
                    order["status"] = "received"
                    
                    logger.info(f"Added dummy SMS to order {order_id}: {test_message['text']}")
            
            return {
                "success": True,
                "status": order["status"],
                "messages": order["messages"],
                "phone_number": order["phone_number"]
            }
            
        except Exception as e:
            logger.error(f"Error in dummy get_sms: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def cancel_number(self, order_id: str) -> bool:
        """–û—Ç–º–µ–Ω–∏—Ç—å –Ω–æ–º–µ—Ä"""
        try:
            if order_id in self.orders:
                self.orders[order_id]["status"] = "cancelled"
                logger.info(f"Cancelled dummy order: {order_id}")
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error in dummy cancel_number: {e}")
            return False
    
    async def get_balance(self) -> Optional[float]:
        """–ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å"""
        try:
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–µ–π–∫–æ–≤—ã–π –±–∞–ª–∞–Ω—Å
            return 100.50
        except Exception as e:
            logger.error(f"Error in dummy get_balance: {e}")
            return None
    
    async def get_countries(self) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω"""
        try:
            countries = {
                "0": {"name": "–†–æ—Å—Å–∏—è", "code": "RU", "flag": "üá∑üá∫", "price": 15},
                "1": {"name": "–£–∫—Ä–∞–∏–Ω–∞", "code": "UA", "flag": "üá∫üá¶", "price": 22},
                "2": {"name": "–ë–µ–ª–∞—Ä—É—Å—å", "code": "BY", "flag": "üáßüáæ", "price": 18},
                "3": {"name": "–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω", "code": "KZ", "flag": "üá∞üáø", "price": 20},
            }
            return countries
            
        except Exception as e:
            logger.error(f"Error in dummy get_countries: {e}")
            return None
    
    async def get_services(self) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–∏—Å–æ–≤"""
        try:
            services = {
                "tg": {"name": "Telegram", "icon": "fab fa-telegram-plane", "price": 15},
                "wa": {"name": "WhatsApp", "icon": "fab fa-whatsapp", "price": 18},
                "vk": {"name": "VKontakte", "icon": "fab fa-vk", "price": 12},
                "ok": {"name": "Odnoklassniki", "icon": "fas fa-circle", "price": 10},
            }
            return services
            
        except Exception as e:
            logger.error(f"Error in dummy get_services: {e}")
            return None

================================================================================
FILE: app\services\sms\providers\__init__.py
================================================================================



================================================================================
FILE: app\utils\telegram.py
================================================================================

import hashlib
import hmac
import json
import logging
from typing import Optional, Dict, Any
from urllib.parse import unquote
from ..core.config import settings

logger = logging.getLogger(__name__)

def validate_telegram_init_data(init_data: str) -> Optional[Dict[str, Any]]:
    """
    –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Telegram WebApp
    
    Args:
        init_data: –°—Ç—Ä–æ–∫–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ –æ—Ç Telegram WebApp
        
    Returns:
        Dict —Å –¥–∞–Ω–Ω—ã–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ None –µ—Å–ª–∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–µ –ø—Ä–æ—à–ª–∞
    """
    try:
        if not init_data or not settings.telegram_bot_token:
            logger.warning("Missing init_data or bot token")
            return None
        
        # –ü–∞—Ä—Å–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        params = {}
        for item in init_data.split('&'):
            if '=' in item:
                key, value = item.split('=', 1)
                params[key] = unquote(value)
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º hash –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        received_hash = params.pop('hash', '')
        if not received_hash:
            logger.warning("No hash in init_data")
            return None
        
        # –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        data_check_string = '\n'.join([
            f"{key}={value}" 
            for key, value in sorted(params.items())
        ])
        
        # –°–æ–∑–¥–∞–µ–º —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á
        secret_key = hmac.new(
            "WebAppData".encode(), 
            settings.telegram_bot_token.encode(), 
            hashlib.sha256
        ).digest()
        
        # –í—ã—á–∏—Å–ª—è–µ–º hash
        calculated_hash = hmac.new(
            secret_key,
            data_check_string.encode(),
            hashlib.sha256
        ).hexdigest()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º hash
        if not hmac.compare_digest(calculated_hash, received_hash):
            logger.warning("Invalid hash in Telegram init_data")
            return None
        
        # –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_data = {}
        if 'user' in params:
            try:
                user_info = json.loads(params['user'])
                user_data = {
                    'id': user_info.get('id'),
                    'first_name': user_info.get('first_name'),
                    'last_name': user_info.get('last_name'),
                    'username': user_info.get('username'),
                    'language_code': user_info.get('language_code'),
                    'is_premium': user_info.get('is_premium', False)
                }
            except json.JSONDecodeError as e:
                logger.error(f"Error parsing user data: {e}")
                return None
        
        logger.info(f"Telegram user validated: {user_data.get('id')}")
        return user_data
        
    except Exception as e:
        logger.error(f"Error validating Telegram init_data: {e}")
        return None

def create_telegram_auth_middleware():
    """–°–æ–∑–¥–∞—Ç—å middleware –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ Telegram"""
    
    async def telegram_auth_middleware(request, call_next):
        """Middleware –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ Telegram"""
        
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É–±–ª–∏—á–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã
        public_paths = ['/docs', '/openapi.json', '/webhook/', '/health']
        if any(request.url.path.startswith(path) for path in public_paths):
            return await call_next(request)
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
        init_data = request.headers.get('X-Telegram-Init-Data')
        if not init_data:
            # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∑–∞–ø—Ä–æ—Å–∞ (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
            init_data = request.query_params.get('init_data')
        
        if init_data:
            user_data = validate_telegram_init_data(init_data)
            if user_data:
                # –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ request
                request.state.telegram_user = user_data
                return await call_next(request)
        
        # –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –º–æ–∂–µ–º –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É
        if settings.debug:
            # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            request.state.telegram_user = {
                'id': 'sample_user',
                'first_name': 'Test',
                'last_name': 'User',
                'username': 'testuser'
            }
            return await call_next(request)
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        from fastapi import HTTPException
        raise HTTPException(status_code=401, detail="Unauthorized")
    
    return telegram_auth_middleware

def get_current_telegram_user(request) -> Optional[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Telegram –∏–∑ request"""
    return getattr(request.state, 'telegram_user', None)

def format_telegram_name(user_data: Dict[str, Any]) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Telegram"""
    first_name = user_data.get('first_name', '')
    last_name = user_data.get('last_name', '')
    username = user_data.get('username', '')
    
    if first_name and last_name:
        return f"{first_name} {last_name}"
    elif first_name:
        return first_name
    elif username:
        return f"@{username}"
    else:
        return "Unknown User"

def is_telegram_premium(user_data: Dict[str, Any]) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å Telegram Premium"""
    return user_data.get('is_premium', False)

def create_webapp_url(path: str = "", start_param: str = "") -> str:
    """–°–æ–∑–¥–∞—Ç—å URL –¥–ª—è Telegram WebApp"""
    base_url = settings.webapp_url.rstrip('/')
    if path:
        path = path.lstrip('/')
        base_url = f"{base_url}/{path}"
    
    if start_param:
        base_url = f"{base_url}?start_param={start_param}"
    
    return base_url

def create_telegram_bot_url(start_param: str = "") -> str:
    """–°–æ–∑–¥–∞—Ç—å URL –¥–ª—è Telegram –±–æ—Ç–∞"""
    bot_token = settings.telegram_bot_token
    if not bot_token:
        return ""
    
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–º—è –±–æ—Ç–∞ –∏–∑ —Ç–æ–∫–µ–Ω–∞
    bot_name = bot_token.split(':')[0] if ':' in bot_token else ""
    
    url = f"https://t.me/{bot_name}"
    if start_param:
        url = f"{url}?start={start_param}"
    
    return url

def validate_telegram_callback_query(callback_data: str) -> bool:
    """–í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å callback query –æ—Ç Telegram"""
    try:
        # –ü—Ä–æ—Å—Ç–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª–∏–Ω—ã –∏ —Ñ–æ—Ä–º–∞—Ç–∞
        if not callback_data or len(callback_data) > 64:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã
        allowed_chars = set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-:")
        if not all(c in allowed_chars for c in callback_data):
            return False
        
        return True
        
    except Exception as e:
        logger.error(f"Error validating callback query: {e}")
        return False

================================================================================
FILE: app\utils\__init__.py
================================================================================

